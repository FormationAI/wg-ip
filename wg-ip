#!/bin/bash
# Usage
#
# Generate an ip
# wg-ip [-4|-6] [--subnet <subnet>] gen <key>
#
# Generate and assign an ip for the specified interface, and for each
# peer, generate an ip and add it to allowed-ips
# wg-ip [-4|-6] [--subnet <subnet>] apply [dev <interface>]
#
# Like apply, but don't actually apply the changes (default action)
# wg-ip [-4|-6] [--subnet <subnet>] dryrun [dev <interface>]
#
# Options: [-4|-6]: use the default ipv4/ipv6 subnet (default -6)

fatal(){
    echo "$@" > /dev/stderr
    exit 1
}

# TODO use this instead of bash-isms for portability
hex2dec(){
  upper=$(echo "$1" | tr 'a-z' 'A-Z')
  echo "ibase=16; $upper" | bc
}

expand_ipv6() {
  ip=$1

  # prepend 0 if we start with :
  grep -qs "^:" <<< $ip && ip="0${ip}"

  # expand ::
  if grep -qs "::" <<< "$ip"; then
    colons=$(sed 's/[^:]//g' <<< "$ip")
    missing=$(sed "s/$colons//" <<< :::::::::)
    expanded=$(sed 's/:/:0/g' <<< $missing)
    ip=$(sed "s/::/$expanded/" <<< $ip)
  fi

  blocks=$(grep -o "[0-9a-f]\+" <<< "$ip")
  set $blocks

  printf "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n" \
    $(( 16#$1 )) \
    $(( 16#$2 )) \
    $(( 16#$3 )) \
    $(( 16#$4 )) \
    $(( 16#$5 )) \
    $(( 16#$6 )) \
    $(( 16#$7 )) \
    $(( 16#$8 ))
}

test_expand_ipv6(){
  tests="2001:db8::2:1        2001:0db8:0000:0000:0000:0000:0002:0001 \
         2001:db8:0:1:1:1:1:1 2001:0db8:0000:0001:0001:0001:0001:0001 \
         2001:db8::1:0:0:1    2001:0db8:0000:0000:0001:0000:0000:0001 \
         2001:db8::1          2001:0db8:0000:0000:0000:0000:0000:0001 \
         ::                   0000:0000:0000:0000:0000:0000:0000:0000 \
         ::1                  0000:0000:0000:0000:0000:0000:0000:0001 \
         1::                  0001:0000:0000:0000:0000:0000:0000:0000"
  set $tests
  status=0
  while [ "$#" != 0 ]; do
    printf "."
    res="$(expand_ipv6 $1)"
    if [ $res != "$2" ]; then
      echo "expand_ipv6 $1: expected $2, got $res"
      status=1
    fi
    shift 2
  done
  return $status
}

compress_ipv6() {
  ip=$1

  blocks=$(grep -o "[0-9a-f]\+" <<< "$ip")
  set $blocks

  # compress leading zeros
  ip=$(printf "%x:%x:%x:%x:%x:%x:%x:%x\n" \
    $(( 16#$1 )) \
    $(( 16#$2 )) \
    $(( 16#$3 )) \
    $(( 16#$4 )) \
    $(( 16#$5 )) \
    $(( 16#$6 )) \
    $(( 16#$7 )) \
    $(( 16#$8 ))
  )

  # prepend : for easier matching
  ip=:$ip

  # :: must compress the longest chain
  for pattern in :0:0:0:0:0:0:0:0 \
           :0:0:0:0:0:0:0 \
           :0:0:0:0:0:0 \
           :0:0:0:0:0 \
           :0:0:0:0 \
           :0:0; do
    if grep -qs $pattern <<< $ip; then
      ip=$(sed "s/$pattern/::/" <<< $ip)
      # if the substitution occured before the end, we have :::
      ip=$(sed 's/:::/::/' <<< $ip)
      break # only one substitution
    fi
  done

  # remove prepending : if necessary
  grep -qs "^:[^:]" <<< $ip && ip=$(sed 's/:\(.*\)/\1/g' <<< $ip)

  echo $ip
}

test_compress_ipv6(){
  tests="2001:0db8:0000:0000:0000:0000:0002:0001 2001:db8::2:1        \
         2001:0db8:0000:0001:0001:0001:0001:0001 2001:db8:0:1:1:1:1:1 \
         2001:0db8:0000:0000:0001:0000:0000:0001 2001:db8::1:0:0:1    \
         2001:0db8:0000:0000:0000:0000:0000:0001 2001:db8::1          \
         0000:0000:0000:0000:0000:0000:0000:0000 ::                   \
         0000:0000:0000:0000:0000:0000:0000:0001 ::1                  \
         0001:0000:0000:0000:0000:0000:0000:0000 1::                 "
  set $tests
  status=0
  while [ "$#" != 0 ]; do
    printf "."
    res="$(compress_ipv6 $1)"
    if [ $res != "$2" ]; then
      echo "compress_ipv6 $1: expected $2, got $res"
      status=1
    fi
    shift 2
  done
  return $status
}

# RFC5952
is_ipv6(){
  expanded="$(expand_ipv6 $1)"
  [ "$1" == "$expanded" ] && return 0
  compressed="$(compress_ipv6 $expanded)"
  [ "$1" == "$compressed" ] && return 0
  return 1
}

test_is_ipv6(){
  tests="2001:db8::2:1        0 \
         2001:db8:0:1:1:1:1:1 0 \
         2001:db8::1:0:0:1    0 \
         2001:db8::1          0 \
         ::                   0 \
         ::1                  0 \
         1::                  0 \
         2001:db8::0:1        1 \
         2001:db8::1:1:1:1:1  1 \
         2001:db8:0:0:1::1    1 \
         2001:DB8::1          1"
  set $tests
  status=0
  while [ "$#" != 0 ]; do
    printf "."
    is_ipv6 $1
    res=$?
    if [ "$res" != "$2" ]; then
      echo "is_ipv6 $1: expected $2, got $res"
      status=1
    fi
    shift 2
  done
  return $status
}

is_ipv4(){
  grep -qs "[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}" <<< $1 \
    || return 1
  for i in $(grep -o "[0-9]\+" <<< $1); do
    if [ "$i" -gt 255 ]; then
      return 1
    fi
  done
  return 0
}

test_is_ipv4(){
  tests="4.2.2.2          0 \
         192.168.1.1      0 \
         0.0.0.0          0 \
         255.255.255.255  0 \
         192.168.0.1      0 \
         a.b.c.d          1 \
         255.255.255.256  1 \
         192.168.0        1 \
         1234.123.123.123 1"
  set $tests
  status=0
  while [ "$#" != 0 ]; do
    printf "."
    is_ipv4 $1
    res=$?
    if [ "$res" != "$2" ]; then
      echo "is_ipv4 $1: expected $2, got $res"
      status=1
    fi
    shift 2
  done
  return $status
}

netmask_bytes(){
  netmask=$1
  len=$2

  res=""
  for i in $(seq 0 $(( len - 1 )) ); do
    b=0
    for j in $(seq 0 7); do
      if [ $(( 8 * i + j )) -lt $netmask ]; then
        b=$(( b | 1 << (7 - j) ))
      fi
    done
    res="$res $b"
  done
  echo $res
}

test_netmask_bytes(){
  status=0
  printf "."
  if [ "$(netmask_bytes 8 4)" != "255 0 0 0" ]; then
    echo "netmask_bytes 8 4: FAIL"
    status=1
  fi
  printf "."
  if [ "$(netmask_bytes 9 4)" != "255 128 0 0" ]; then
    echo "netmask_bytes 8 4: FAIL"
    status=1
  fi
  return $status
}

# key [subnet]
gen_ipv6(){
  pubkey=$1
  subnet=$2

  prefix=$(cut -d/ -f1 <<< $subnet)
  if ! is_ipv6 $prefix; then
    fatal "$prefix: not a valid ipv6 address"
  fi
  prefix=$(expand_ipv6 $prefix)

  netmask=$(cut -d/ -f2 <<< $subnet)
  if [ "$netmask" -le 0 -o "$netmask" -ge 128 ]; then
    fatal "$netmask: invalid netmask"
  fi

  pubkeychecksum=$(sha256sum <<< $pubkey)
  genbytes=( $(grep -o "[0-9a-f]\{2\}" <<< $pubkeychecksum) )
  netbytes=( $(grep -o "[0-9a-f]\{2\}" <<< $prefix) )

  maskbytes=( $(netmask_bytes $netmask 16) )

  bytes=""
  for i in $(seq 0 15); do
    m=${maskbytes[$i]}
    m_flipped=$(( m ^ 255 ))
    b=$(( (16#${netbytes[i]} & m) | (16#${genbytes[i]} & m_flipped) ))
    bytes="$bytes $b"
  done

  printf "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n" \
    $bytes

}

test_gen_ipv6() {
  tests="foo fd1a:6126:2887::/48 fd1a:6126:2887:f9b1:d61e:21e7:96d7:8dcc \
         bar fd1a:6126:2887::/48 fd1a:6126:2887:6691:8c98:63af:ca94:2d0f \
         foo fd1a:6126:2887::/49 fd1a:6126:2887:79b1:d61e:21e7:96d7:8dcc \
         bar fd1a:6126:2887::/49 fd1a:6126:2887:6691:8c98:63af:ca94:2d0f \
         foo 2001:db8::/64       2001:0db8:0000:0000:d61e:21e7:96d7:8dcc \
         bar 2001:db8::/64       2001:0db8:0000:0000:8c98:63af:ca94:2d0f"
  set $tests
  status=0
  while [ "$#" != 0 ]; do
    printf "."
    res="$(gen_ipv6 $1 $2)"
    if [ "$res" != "$3" ]; then
      echo "gen_ipv6 $1 $2: expected $3, got $res"
      status=1
    fi
    shift 3
  done
  return $status
}

# key [subnet]
gen_ipv4(){
  pubkey=$1
  subnet=$2

  prefix=$(cut -d/ -f1 <<< $subnet)
  if ! is_ipv4 $prefix; then
    fatal "$prefix: not a valid ipv4 address"
  fi

  netmask=$(cut -d/ -f2 <<< $subnet)
  if [ "$netmask" -le 0 -o "$netmask" -ge 32 ]; then
    fatal "$netmask: invalid netmask"
  fi

  pubkeychecksum=$(sha256sum <<< $pubkey)
  genbytes=( $(grep -o "[0-9a-f]\{2\}" <<< $pubkeychecksum) )
  netbytes=( $(grep -o "[0-9]\+" <<< $prefix) )

  maskbytes=( $(netmask_bytes $netmask 4) )

  bytes=""
  for i in $(seq 0 3); do
    m=${maskbytes[$i]}
    m_flipped=$(( m ^ 255 ))
    b=$(( (${netbytes[i]} & m) | (16#${genbytes[i]} & m_flipped) ))
    bytes="$bytes $b"
  done

  printf "%d.%d.%d.%d\n" \
    ${bytes[@]}

}

test_gen_ipv4() {
  tests="foo 10.0.0.0/8    10.187.157.128 \
         bar 10.0.0.0/8    10.134.94.149 \
         foo 10.0.0.0/9    10.59.157.128 \
         bar 10.0.0.0/9    10.6.94.149
         foo 172.16.0.0/12 172.27.157.128 \
         bar 172.16.0.0/12 172.22.94.149"
  set $tests
  status=0
  while [ "$#" != 0 ]; do
    printf "."
    res="$(gen_ipv4 $1 $2)"
    if [ "$res" != "$3" ]; then
      echo "gen_ipv4 $1: expected $3, got $res"
      status=1
    fi
    shift 3
  done
  return $status
}

gen_ip(){
  pubkey=$1
  subnet=$2
  prefix=$(cut -d/ -f1 <<< $subnet)
  if is_ipv6 $prefix; then
    gen_ipv6 $1 $2
  else
    gen_ipv4 $1 $2
  fi
}

dryrun_iface(){
  subnet="$1"
  iface="$2"

  prefix=$(cut -d/ -f1 <<< $subnet)
  netmask=$(cut -d/ -f2 <<< $subnet)

  ipbits=128
  if is_ipv4 $prefix; then
    ipbits=32
  fi

  # configure address
  iface_pubkey=$(wg show "$iface" public-key)
  iface_ip=$(gen_ip "$iface_pubkey" "$subnet")
  echo "ip address add $iface_ip/$netmask dev $iface"

  # configure allowed ips on each peer
  for peer_pubkey in $(wg show $iface peers); do
    peer_ip=$(gen_ip "$peer_pubkey" "$subnet")
    allowed_ips=$(wg show "$iface" allowed-ips | grep "$peer_pubkey" | cut -f2)
    allowed_ips="$allowed_ips $peer_ip/$ipbits"
    allowed_ips="$(tr ' ' ',' <<< $allowed_ips)"
    echo "wg set wg0 peer $peer_pubkey allowed-ips $allowed_ips"
  done
}

test_dryrun_iface(){
  printf "."
  wg(){
    wg_ "$@"
  }
  expected_output=$(mktemp)
cat <<EOF > $expected_output
ip address add 2001:0db8:0002:0000:d61e:21e7:96d7:8dcc/64 dev wg0
wg set wg0 peer bar allowed-ips 2001:db8::/64,fd00::/128,2001:0db8:0002:0000:8c98:63af:ca94:2d0f/128
wg set wg0 peer baz allowed-ips 2001:db8::1/64,2001:0db8:0002:0000:ae7b:f4a1:177b:2b31/128
wg set wg0 peer zuf allowed-ips 2001:0db8:0002:0000:515b:c456:4a37:f06f/128
EOF
  status=0
  differences=$(dryrun_iface "2001:db8:2::/64" "wg0" | diff - "$expected_output")
  if [ "$?" != 0 ]; then
    echo "test_dryrun_iface: $differences"
    status=1
  fi
  rm $expected_output
  unset -f wg
  return $status
}

dryrun(){
  subnet="$1"
  iface="$2"

  if [ "$iface" != "" ]; then
    dryrun_iface "$subnet" "$iface"
  else
    for iface in $(wg show interfaces); do
      dryrun_iface "$subnet" "$iface"
    done
  fi
}

test_dryrun(){
  printf "."
  wg(){
    wg_ "$@"
  }
  expected_output=$(mktemp)
cat <<EOF > $expected_output
ip address add 172.27.157.128/12 dev wg0
wg set wg0 peer bar allowed-ips 2001:db8::/64,fd00::/128,172.22.94.149/32
wg set wg0 peer baz allowed-ips 2001:db8::1/64,172.23.167.251/32
wg set wg0 peer zuf allowed-ips 172.29.98.139/32
EOF
  status=0
  differences=$(dryrun 172.16.0.0/12 | diff - "$expected_output")
  if [ "$?" != 0 ]; then
    echo "test_dryrun: $differences"
    status=1
  fi
  rm $expected_output
  unset -f wg
  return $status
}

wg_(){
  case "$1" in
    show)
      if [ "$2" == "interfaces" ]; then
        echo "wg0"
        return 0
      fi
      if [ "$2" == "wg0" ]; then
        if [ "$3" == "public-key" ]; then
          echo "foo"
          return 0
        fi
        if [ "$3" == "peers" ]; then
          echo "bar"
          echo "baz"
          echo "zuf"
          return 0
        fi
        if [ "$3" == "allowed-ips" ]; then
          echo "bar	2001:db8::/64 fd00::/128"
          echo "baz	2001:db8::1/64"
        fi
      fi
      ;;
  esac
}

runtests() {
  script=$(readlink -f $0)
  testfuncs=$(grep "^test_.*()" $script | sed 's/().*$//g')
  for i in $testfuncs; do
    printf "%s" $i
    if $i; then
      echo PASS
    else
      echo FAIL
    fi
  done
}

# default values
subnet4="10.0.0.0/8"
subnet6="fd1a:6126:2887::/48"
subnet=$subnet6
device=""
pubkey=""

while [ "$#" != 0 ]; do
  case "$1" in
    --test)
      runtests
      exit
      ;;
    -4)
      subnet=$subnet4
      shift
      ;;
    -6)
      subnet=$subnet6
      shift
      ;;
    --subnet)
      shift
      prefix=$(cut -d/ -f1 <<< $1)
      if is_ipv6 $prefix; then
        subnet="$1"
        ipbits=128
      elif is_ipv4 $prefix; then
        subnet="$1"
        ipbits=32
      else
        fail "$1: not a valid subnet"
      fi
      netmask=$(cut -d/ -f2 <<< "$1")
      if [ "$netmask" -le 0 -o "$netmask" -ge "$ipbits" ]; then
        fatal "$netmask: not a valid netmask for this prefix"
      fi
      shift
      ;;
    gen)
      shift
      gen_ip "$1" "$subnet"
      exit
      ;;
    dev)
      shift
      device="$1"
      shift
      ;;
    dryrun)
      if [ "$UID" != 0 ]; then
        fatal "this command requires root access"
      fi
      dryrun "$subnet" "$device"
      exit
      ;;
    apply)
      if [ "$UID" != 0 ]; then
        fatal "this command requires root access"
      fi
      dryrun "$subnet" "$device" | sh
      exit
      ;;
    *)
      fatal "$1: invalid argument"
      shift
      ;;
  esac
done

# perform default action
if [ "$UID" != 0 ]; then
  fatal "this command requires root access"
fi
dryrun "$subnet" "$device"
